# 开发记录

## V1.8

- 引入 `libjpeg` 库，用 JPEG 做颜色编码
- 为了方便测试（其实是怕改坏）保留了原来的函数，建立在原来函数基础上的新函数命名为 `funcname_using_JPEG()`

待优化：

1.  新函数应与原函数合并

2. 当前 JPEG 压缩质量控制参数 `quality` 在 `Slice::Octree_encode_using_JPEG()` 中，应改为由 `PCEncoder` 传递，便于控制
3. 当前点位置编码和 JPEG 的颜色编码比较割裂，尤其是 Slice 解码时对树的操作比较僵硬

## V1.7

- 重新整理流程，清除了一些之前调整留下了的多余代码
- 额外开辟了一条DFS遍历颜色的路径

## V1.6

- 真的建了棵树，方便后面的DFS
- 去掉了深度控制，这个东西在采样的时候做更合理
- 去掉了单枝根节点削除，就几个字节的东西没啥意义
- 部分较为占用内存的结果使用move进行优化
- 调整了一些流程的结构

## V1.5.1

- 修复了色度抽样后颜色异常的bug

## V1.5

- 先建立八叉树结构，再对八叉树做压缩
- 优化了部分代码

Bug: 启用色度抽样后颜色异常，初步判断可能是八叉树色度抽样函数`Octree_Chroma_Subsample`有问题

待优化: 八叉树节点的 `sliceDataIndex`属性占用大量内存，建树过程应想办法合理释放内存（clear好像没有用）

## V1.4

- 将几何和颜色的熵编码分开，可以分别对各自的特征进行更有效的编码
- 调整了一下Slice的构造函数接口
- 修复了某个异常没有加throw关键字的逗比问题

## V1.3.1

修正量化后数值溢出的问题，做了个反量化进行校正

## V1.3

加入简单的截取位舍入量化器

## V1.2

- 增加路径合法性检测，不然会死循环的
- 简单的树分裂，保证差分预测可以在int8内使用
- 削除单枝根节点
- 加入预测编码

## V1.1

- 引入zlib库，加入zlib压缩

## V1.0

- 分散各组件，减少耦合，后面改动起来更方便
- 加入色度采样的开关
- 加入熵编码的选项，加入完全负优化的游长编码（可能以后能用到吧就留着先）
- 增加了颜色空间的选项
- 增加了文本格式的选项

总之就是尽量多加了些控制开关，虽然现在有些只是摆设不过后面有需要的话还是会用到的

后续的可能开发方向：

- 树的分裂/检测相关算法，更好地切分场景，这也意味着需要调整现有的单次BFS建树的方法
- 颜色的预测和变换相关
- 针对几何流和颜色流分别进行熵编码
- 更优的熵编码方案

尽管现有的图像/视频处理方法已经提供了很好的思路借鉴，但它们不能原封不动地应用到高度稀疏的点云数据中，我们还是需要想一下可能的一些改进

## V0.6

加入熵编码

## V0.5

1. 深度截断由限深改为剪除底层的层数，对不同大小的分片行为不太一样
2. 简化了八叉树的输出流，现在不需要把叶子层那堆0写进文件了
3. 使用了类似YUV4:2:0的色度采样，看起来似乎不错

## V0.4

增加了一个直接截断深度控制，非常暴力

## V0.3

封装到了类里面，大概可能会好看一点点？

## V0.2

1. 目前只接受整数坐标，内部使用非负整数坐标，处理起来更方便，在流程头尾进行场景平移
2. 这里没有检测相同坐标重叠点，不过这个正常来说大概没有必要？
3. 暂时使用无损编码，颜色与坐标点伴随编码
4. 分片方法由固定N划分改为固定分片大小，分片数目可变，后续也可能支持分片合并和分裂
5. 颜色值伴随几何八叉树的构建同步编码
6. 分片的封包使用更加独立的方案，避免强依赖，理论上可以比较容易并行处理

## V0.1

1. 首先将场景平移使坐标都为非负数，然后将场景切分为20x20x20的切片，对每个切片单独编码
2. 对每个切片，首先合并重复点（浮点==）
3. 进行八叉树分裂，当某个节点内仅有一个点且该点足够接近节点原点时（这里取各坐标轴0.1范围内），用节点近似代表该点，否则继续分裂直到分裂上限，此时截断

## issues/TODO

1. 加入小数坐标支持，需要增加采样相关的前后处理（采样精度相关设置）
2. 是否需要检测重复点？
3. 加入更加自由的分片方式，比如缩小到分片内部点包围盒的大小
4. 分片内部八叉树深度自适应限制（有损质量选项）
5. 使用插值颜色+预测、量化等的方法编码颜色（图像视频编码的思想，根据坐标值占有位还原）
6. 是否可以使用面片对切片内的点进行拟合？在八叉树和面片之间自适应切换？相邻面片是否可以合并？
7. 可能在平缓的面上缩减点的数量？（曲面拟合）
